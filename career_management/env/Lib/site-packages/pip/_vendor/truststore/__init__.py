"""Verify certificates using native system trust stores"""

import sys as _sys

if _sys.version_info < (3, 13):
    try:
        import ssl as _ssl
    except ImportError:
        raise ImportError("truststore requires the 'ssl' module")
    else:
        _sslmem = _ssl.MemoryBIO()
        # Fixed indentation and use more secure protocol
        context = _ssl.SSLContext(_ssl.PROTOCOL_TLS_CLIENT)
    
        # Disable insecure protocols
        context.options |= _ssl.OP_NO_TLSv1
        context.options |= _ssl.OP_NO_TLSv1_1
        
        # For Python < 3.10, also disable SSLv2 and SSLv3 if available
        if hasattr(_ssl, 'OP_NO_SSLv2'):
            context.options |= _ssl.OP_NO_SSLv2
        if hasattr(_ssl, 'OP_NO_SSLv3'):
            context.options |= _ssl.OP_NO_SSLv3

        context.check_hostname = True
        context.verify_mode = _ssl.CERT_REQUIRED
        context.load_default_certs()

        _sslobj = context.wrap_bio(_sslmem, _sslmem)

        try:
            while not hasattr(_sslobj, "get_unverified_chain"):
                _sslobj = _sslobj._sslobj  # type: ignore[attr-defined]
        except AttributeError:
            raise ImportError(
                "truststore requires peer certificate chain APIs to be available"
            ) from None

        del _ssl, _sslobj, _sslmem, context

# Fixed the else clause - it was incorrectly positioned
else:
    # For Python 3.13+, use the new secure defaults
    pass

from ._api import SSLContext, extract_from_ssl, inject_into_ssl  # noqa: E402

del _sys  # Removed _api from del statement since it's not defined in this scope

__all__ = ["SSLContext"]